// DeepSeek API Integration for Yesterday Once More

// Get API key from config file if available, otherwise use a placeholder
// In production, the actual key should be in config.js which is not uploaded to GitHub
const DEEPSEEK_API_KEY = window.CONFIG?.DEEPSEEK_API_KEY || 'YOUR_API_KEY_HERE';

// Only log the key format in production (for security)
console.log('Using DeepSeek API Key:', DEEPSEEK_API_KEY.substring(0, 5) + '...');

// DeepSeek API endpoints
const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';
// Fallback to proxy if needed
const CORS_PROXY = '';

// DeepSeek model to use
const DEEPSEEK_MODEL = window.CONFIG?.DEEPSEEK_MODEL || 'deepseek-V3';

// Test the API connection when the script loads
testApiConnection().then(success => {
    if (success) {
        console.log('DeepSeek API connection verified successfully!');
    } else {
        console.error('DeepSeek API connection failed. Please check your API key and network connection.');
    }
});

/**
 * Call the DeepSeek API to generate perfume details based on user input
 * @param {string} userInput - The user's description or inspiration
 * @param {Array} mediaFiles - Optional array of media files (images, audio, video)
 * @returns {Promise<Object>} - The perfume details generated by the API
 */
async function generatePerfume(userInput, mediaFiles = []) {
    console.log('Generating perfume for input:', userInput);

    try {
        // Prepare the request payload
        const payload = {
            model: DEEPSEEK_MODEL,
            messages: [
                {
                    role: 'system',
                    content: 'You are the AI assistant for Yesterday Once More (昨日重现), a pioneering fragrance house that combines AI scent mapping, exclusive molecules, and market intelligence. Your expertise is in creating unique perfume formulations based on user descriptions or media. Your responses should be creative yet professional, using perfumery terminology. For each fragrance, include top notes, heart notes, base notes, a name that reflects the "Yesterday Once More" aesthetic (evoking nostalgia and memories), and a poetic description that captures the essence of remembering beautiful moments from the past.'
                },
                {
                    role: 'user',
                    content: await formatUserContent(userInput, mediaFiles)
                }
            ],
            temperature: 0.7,
            max_tokens: 800
        };

        console.log('Sending request to DeepSeek API with payload:', JSON.stringify(payload));

        // Make the API request
        const response = await fetch(DEEPSEEK_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
            },
            body: JSON.stringify(payload)
        });

        console.log('API response status:', response.status);

        // Check if the response is successful
        if (!response.ok) {
            const errorText = await response.text();
            console.error('API error response:', errorText);
            throw new Error(`API request failed with status ${response.status}: ${errorText}`);
        }

        // Parse the response
        const data = await response.json();
        console.log('API response data:', data);

        // Parse the AI response to extract perfume details
        const aiResponse = data.choices[0].message.content;
        console.log('AI response content:', aiResponse);

        // Process the AI response to extract structured data
        return processPerfumeResponse(aiResponse, userInput, mediaFiles);
    } catch (error) {
        console.error('Error calling DeepSeek API:', error);

        // Try direct chat for debugging
        console.log('Attempting direct chat with DeepSeek...');
        try {
            const chatResponse = await directChat(userInput);
            if (chatResponse && !chatResponse.error) {
                return chatResponse;
            }
        } catch (chatError) {
            console.error('Direct chat also failed:', chatError);
        }

        // Show a more detailed error message in the console
        console.log('API Key used:', DEEPSEEK_API_KEY);
        console.log('API URL used:', DEEPSEEK_API_URL);

        return {
            error: true,
            message: `Failed to generate perfume: ${error.message}`,
            fallback: true,
            name: 'Inspiration Blend',
            topNotes: 'Bergamot, Pink Pepper, Water Lily',
            heartNotes: 'Jasmine Sambac, Orris Root, Tea Leaves',
            baseNotes: 'Amber, Musk, Cedarwood',
            description: 'A balanced fragrance with fresh top notes and a warm base.'
        };
    }
}

/**
 * Process the raw AI response into structured perfume data
 * @param {string} aiResponse - The raw text response from the AI
 * @param {string} originalInput - The original user input
 * @param {Array} mediaFiles - Any media files that were included
 * @returns {Object} - Structured perfume data
 */
function processPerfumeResponse(aiResponse, originalInput, mediaFiles = []) {
    try {
        // Default values in case parsing fails
        let perfumeData = {
            name: 'NEON DROWNING',
            topNotes: '',
            heartNotes: '',
            baseNotes: '',
            description: '',
            originalInput: originalInput,
            hasMedia: mediaFiles.length > 0
        };

        // Try to extract the perfume name
        const nameMatch = aiResponse.match(/name:?\s*([^\n.]+)/i) ||
                          aiResponse.match(/called:?\s*"?([^"\n.]+)"?/i) ||
                          aiResponse.match(/titled:?\s*"?([^"\n.]+)"?/i);
        if (nameMatch && nameMatch[1]) {
            perfumeData.name = nameMatch[1].trim();
        }

        // Extract top notes
        const topMatch = aiResponse.match(/top notes?:?\s*([^\n.]+)/i);
        if (topMatch && topMatch[1]) {
            perfumeData.topNotes = topMatch[1].trim();
        }

        // Extract heart/middle notes
        const heartMatch = aiResponse.match(/heart notes?:?\s*([^\n.]+)/i) ||
                           aiResponse.match(/middle notes?:?\s*([^\n.]+)/i);
        if (heartMatch && heartMatch[1]) {
            perfumeData.heartNotes = heartMatch[1].trim();
        }

        // Extract base notes
        const baseMatch = aiResponse.match(/base notes?:?\s*([^\n.]+)/i);
        if (baseMatch && baseMatch[1]) {
            perfumeData.baseNotes = baseMatch[1].trim();
        }

        // Extract description or inspiration analysis
        const descMatch = aiResponse.match(/inspiration analysis:?\s*([^\n]+(?:\n[^\n]+)*)/i) ||
                          aiResponse.match(/description:?\s*([^\n]+(?:\n[^\n]+)*)/i);
        if (descMatch && descMatch[1]) {
            perfumeData.description = descMatch[1].trim();
        }

        // Generate a color scheme based on the input
        perfumeData.colorScheme = generateColorScheme(originalInput, aiResponse);

        return perfumeData;
    } catch (error) {
        console.error('Error processing AI response:', error);
        return {
            name: 'Custom Blend',
            topNotes: 'Citrus, Herbal, Spice',
            heartNotes: 'Floral, Fruity, Green',
            baseNotes: 'Woody, Musky, Amber',
            description: 'A unique blend inspired by your description.',
            colorScheme: {
                primary: 'from-blue-200 to-purple-300',
                accent: 'bg-purple-400'
            }
        };
    }
}

/**
 * Generate a color scheme based on the user input and AI response
 * @param {string} input - The user's description
 * @param {string} aiResponse - The AI's response
 * @returns {Object} - Color scheme for the perfume visualization
 */
function generateColorScheme(input, aiResponse = '') {
    // Default NEON DROWNING color scheme - Sunburn Pink & Chlorine Blue
    let colorScheme = {
        primary: '#FF6B6B',  // Sunburn Pink
        secondary: '#00C4CC', // Chlorine Blue
        gradient: 'linear-gradient(135deg, #FF6B6B, #00C4CC)',
        textColor: 'white'
    };

    // Combine input and AI response for better color analysis
    const combinedText = (input + ' ' + aiResponse).toLowerCase();

    // Yesterday Once More color palettes
    if (combinedText.includes('ocean') || combinedText.includes('sea') || combinedText.includes('water')) {
        colorScheme.primary = '#00C4CC'; // Chlorine Blue
        colorScheme.secondary = '#7B68EE'; // Lavender
        colorScheme.gradient = 'linear-gradient(135deg, #00C4CC, #7B68EE)';
    } else if (combinedText.includes('forest') || combinedText.includes('green') || combinedText.includes('nature')) {
        colorScheme.primary = '#00D9B8'; // Mint
        colorScheme.secondary = '#7D67FF'; // Twilight
        colorScheme.gradient = 'linear-gradient(135deg, #00D9B8, #7D67FF)';
    } else if (combinedText.includes('rose') || combinedText.includes('love') || combinedText.includes('passion')) {
        colorScheme.primary = '#FF5E87'; // Neon Pink
        colorScheme.secondary = '#FF7EB3'; // Bubblegum
        colorScheme.gradient = 'linear-gradient(135deg, #FF5E87, #FF7EB3)';
    } else if (combinedText.includes('sunset') || combinedText.includes('warm') || combinedText.includes('autumn')) {
        colorScheme.primary = '#FF9E7D'; // Sunset
        colorScheme.secondary = '#FF8C42'; // Tangerine
        colorScheme.gradient = 'linear-gradient(135deg, #FF9E7D, #FF8C42)';
    } else if (combinedText.includes('night') || combinedText.includes('dark') || combinedText.includes('mysterious')) {
        colorScheme.primary = '#7D67FF'; // Twilight
        colorScheme.secondary = '#7B68EE'; // Lavender
        colorScheme.gradient = 'linear-gradient(135deg, #7D67FF, #7B68EE)';
    } else if (combinedText.includes('sunshine') || combinedText.includes('happy') || combinedText.includes('bright')) {
        colorScheme.primary = '#FF8C42'; // Tangerine
        colorScheme.secondary = '#0096C7'; // Ocean
        colorScheme.gradient = 'linear-gradient(135deg, #FF8C42, #0096C7)';
    }

    // Add intensity value based on the content
    colorScheme.intensity = combinedText.includes('intense') || combinedText.includes('strong') ? 0.9 : 0.7;

    return colorScheme;
}

/**
 * Alternative direct chat with DeepSeek API
 * This is a fallback method that uses a different endpoint or approach
 * @param {string} userInput - The user's message
 * @param {Array} mediaFiles - Optional array of media files
 * @returns {Promise<Object>} - Processed perfume data
 */
async function directChat(userInput, mediaFiles = []) {
    try {
        // Try using a different endpoint or model
        const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
            },
            body: JSON.stringify({
                model: DEEPSEEK_MODEL,
                messages: [
                    {
                        role: 'system',
                        content: 'You are the AI assistant for Yesterday Once More (昨日重现), a fragrance house. Create a unique perfume with a name that reflects nostalgia and memories. Include top notes, heart notes, base notes, and a poetic description.'
                    },
                    {
                        role: 'user',
                        content: await formatUserContent(userInput, mediaFiles)
                    }
                ],
                temperature: 0.5,
                max_tokens: 500
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Direct chat failed with status ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        const aiResponse = data.choices[0].message.content;

        return processPerfumeResponse(aiResponse, userInput, mediaFiles);
    } catch (error) {
        console.error('Direct chat error:', error);
        throw error;
    }
}

/**
 * Test the API connection with a simple request
 * @returns {Promise<boolean>} - Whether the connection was successful
 */
async function testApiConnection() {
    try {
        const response = await fetch('https://api.deepseek.com/v1/models', {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
            }
        });

        if (!response.ok) {
            throw new Error(`API connection test failed with status ${response.status}`);
        }

        const data = await response.json();
        console.log('API connection successful. Available models:', data);
        return true;
    } catch (error) {
        console.error('API connection test failed:', error);
        return false;
    }
}



/**
 * Format the user content including any media files
 * @param {string} userMessage - The user's text message
 * @param {Array} mediaFiles - Array of media files
 * @returns {Promise<string|Array>} - Formatted content
 */
async function formatUserContent(userMessage, mediaFiles = []) {
    // If no media files, just return the text message
    if (mediaFiles.length === 0) {
        return userMessage || "请为我创建一款昨日重现风格的香水";
    }

    // For now, we'll just add a description of the media files
    // In a real implementation, you would process the files and potentially
    // use multimodal capabilities of the API if available
    let mediaDescription = "\n\n[附带的媒体文件: ";

    mediaFiles.forEach((file, index) => {
        if (index > 0) mediaDescription += ", ";

        if (file.type.startsWith('image/')) {
            mediaDescription += `图片 (${file.type})`;
        } else if (file.type.startsWith('audio/')) {
            mediaDescription += `音频 (${file.type})`;
        } else if (file.type.startsWith('video/')) {
            mediaDescription += `视频 (${file.type})`;
        } else {
            mediaDescription += `文件 (${file.type})`;
        }
    });

    mediaDescription += "]";

    return (userMessage || "请基于这些媒体文件为我创建一款昨日重现风格的香水") + mediaDescription;
}

// Export the functions and API key for use in other files
window.YesterdayOnceMoreAPI = {
    DEEPSEEK_API_KEY,
    DEEPSEEK_MODEL,
    generatePerfume,
    testApiConnection,
    generateColorScheme
};

// For backward compatibility
window.PerfumeAPI = window.YesterdayOnceMoreAPI;
window.NeonDrowningAPI = window.YesterdayOnceMoreAPI; // For backward compatibility
